import { AfterContentInit, ChangeDetectorRef, EventEmitter } from '@angular/core';
import { DateAdapter } from '../datetime/date-adapter';
import { MatDateFormats } from '../datetime/date-formats';
import { Directionality } from '@angular/cdk/bidi';
import { SatCalendarCell } from './calendar-body';
/**
 * An internal component used to display a single month in the datepicker.
 * @docs-private
 */
import * as ɵngcc0 from '@angular/core';
export declare class SatMonthView<D> implements AfterContentInit {
    private _changeDetectorRef;
    private _dateFormats;
    _dateAdapter: DateAdapter<D>;
    private _dir;
    /** Current start of interval. */
    beginDate: D | null;
    private _beginDate;
    /** Current end of interval. */
    endDate: D | null;
    private _endDate;
    /** Allow selecting range of dates. */
    rangeMode: boolean;
    /** First day of interval. */
    _beginDateNumber: number | null;
    _endDateNumber: number | null;
    /** Whenever full month is inside dates interval. */
    _rangeFull: boolean | null;
    /** Whenever user already selected start of dates interval. */
    private _beginDateSelected;
    /**
     * The date to display in this month view (everything other than the month and year is ignored).
     */
    activeDate: D;
    private _activeDate;
    /** The currently selected date. */
    selected: D | null;
    private _selected;
    /** The minimum selectable date. */
    minDate: D | null;
    private _minDate;
    /** The maximum selectable date. */
    maxDate: D | null;
    private _maxDate;
    /** A function used to filter which dates are selectable. */
    dateFilter: (date: D) => boolean;
    /** Emits when a new date is selected. */
    readonly selectedChange: EventEmitter<D | null>;
    /** Emits when any date is selected. */
    readonly _userSelection: EventEmitter<void>;
    /** Emits when any date is activated. */
    readonly activeDateChange: EventEmitter<D>;
    /** The body of calendar table */
    _matCalendarBody: any;
    /** The label for this month (e.g. "January 2017"). */
    _monthLabel: string;
    /** Grid of calendar cells representing the dates of the month. */
    _weeks: SatCalendarCell[][];
    /** The number of blank cells in the first row before the 1st of the month. */
    _firstWeekOffset: number;
    /**
     * The date of the month that the currently selected Date falls on.
     * Null if the currently selected Date is in another month.
     */
    _selectedDate: number | null;
    /** The date of the month that today falls on. Null if today is in another month. */
    _todayDate: number | null;
    /** The names of the weekdays. */
    _weekdays: {
        long: string;
        narrow: string;
    }[];
    constructor(_changeDetectorRef: ChangeDetectorRef, _dateFormats: MatDateFormats, _dateAdapter: DateAdapter<D>, _dir?: Directionality);
    ngAfterContentInit(): void;
    /** Handles when a new date is selected. */
    _dateSelected(date: number): void;
    /** Handles keydown events on the calendar body when calendar is in month view. */
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    /** Initializes this month view. */
    _init(): void;
    /** Focuses the active cell after the microtask queue is empty. */
    _focusActiveCell(): void;
    /** Creates SatCalendarCells for the dates in this month. */
    private _createWeekCells();
    /** Date filter for the month */
    private _shouldEnableDate(date);
    /**
     * Gets the date in this month that the given Date falls on.
     * Returns null if the given Date is in another month.
     */
    private _getDateInCurrentMonth(date);
    /** Checks whether the 2 dates are non-null and fall within the same month of the same year. */
    private _hasSameMonthAndYear(d1, d2);
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    private _getValidDateOrNull(obj);
    /** Determines whether the user has the RTL layout direction. */
    private _isRtl();
    /** Updates range full parameter on each begin or end of interval update.
     * Necessary to display calendar-body correctly
     */
    private updateRangeSpecificValues();
    static ɵfac: ɵngcc0.ɵɵFactoryDef<SatMonthView<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<SatMonthView<any>, "sat-month-view", ["matMonthView"], { "rangeMode": "rangeMode"; "beginDate": "beginDate"; "endDate": "endDate"; "activeDate": "activeDate"; "selected": "selected"; "minDate": "minDate"; "maxDate": "maxDate"; "dateFilter": "dateFilter"; }, { "selectedChange": "selectedChange"; "_userSelection": "_userSelection"; "activeDateChange": "activeDateChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGgtdmlldy5kLnRzIiwic291cmNlcyI6WyJtb250aC12aWV3LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdG9yUmVmLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGVBZGFwdGVyIH0gZnJvbSAnLi4vZGF0ZXRpbWUvZGF0ZS1hZGFwdGVyJztcbmltcG9ydCB7IE1hdERhdGVGb3JtYXRzIH0gZnJvbSAnLi4vZGF0ZXRpbWUvZGF0ZS1mb3JtYXRzJztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgU2F0Q2FsZW5kYXJDZWxsIH0gZnJvbSAnLi9jYWxlbmRhci1ib2R5Jztcbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHVzZWQgdG8gZGlzcGxheSBhIHNpbmdsZSBtb250aCBpbiB0aGUgZGF0ZXBpY2tlci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU2F0TW9udGhWaWV3PEQ+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgcHJpdmF0ZSBfZGF0ZUZvcm1hdHM7XG4gICAgX2RhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxEPjtcbiAgICBwcml2YXRlIF9kaXI7XG4gICAgLyoqIEN1cnJlbnQgc3RhcnQgb2YgaW50ZXJ2YWwuICovXG4gICAgYmVnaW5EYXRlOiBEIHwgbnVsbDtcbiAgICBwcml2YXRlIF9iZWdpbkRhdGU7XG4gICAgLyoqIEN1cnJlbnQgZW5kIG9mIGludGVydmFsLiAqL1xuICAgIGVuZERhdGU6IEQgfCBudWxsO1xuICAgIHByaXZhdGUgX2VuZERhdGU7XG4gICAgLyoqIEFsbG93IHNlbGVjdGluZyByYW5nZSBvZiBkYXRlcy4gKi9cbiAgICByYW5nZU1vZGU6IGJvb2xlYW47XG4gICAgLyoqIEZpcnN0IGRheSBvZiBpbnRlcnZhbC4gKi9cbiAgICBfYmVnaW5EYXRlTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICAgIF9lbmREYXRlTnVtYmVyOiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiBXaGVuZXZlciBmdWxsIG1vbnRoIGlzIGluc2lkZSBkYXRlcyBpbnRlcnZhbC4gKi9cbiAgICBfcmFuZ2VGdWxsOiBib29sZWFuIHwgbnVsbDtcbiAgICAvKiogV2hlbmV2ZXIgdXNlciBhbHJlYWR5IHNlbGVjdGVkIHN0YXJ0IG9mIGRhdGVzIGludGVydmFsLiAqL1xuICAgIHByaXZhdGUgX2JlZ2luRGF0ZVNlbGVjdGVkO1xuICAgIC8qKlxuICAgICAqIFRoZSBkYXRlIHRvIGRpc3BsYXkgaW4gdGhpcyBtb250aCB2aWV3IChldmVyeXRoaW5nIG90aGVyIHRoYW4gdGhlIG1vbnRoIGFuZCB5ZWFyIGlzIGlnbm9yZWQpLlxuICAgICAqL1xuICAgIGFjdGl2ZURhdGU6IEQ7XG4gICAgcHJpdmF0ZSBfYWN0aXZlRGF0ZTtcbiAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRlLiAqL1xuICAgIHNlbGVjdGVkOiBEIHwgbnVsbDtcbiAgICBwcml2YXRlIF9zZWxlY3RlZDtcbiAgICAvKiogVGhlIG1pbmltdW0gc2VsZWN0YWJsZSBkYXRlLiAqL1xuICAgIG1pbkRhdGU6IEQgfCBudWxsO1xuICAgIHByaXZhdGUgX21pbkRhdGU7XG4gICAgLyoqIFRoZSBtYXhpbXVtIHNlbGVjdGFibGUgZGF0ZS4gKi9cbiAgICBtYXhEYXRlOiBEIHwgbnVsbDtcbiAgICBwcml2YXRlIF9tYXhEYXRlO1xuICAgIC8qKiBBIGZ1bmN0aW9uIHVzZWQgdG8gZmlsdGVyIHdoaWNoIGRhdGVzIGFyZSBzZWxlY3RhYmxlLiAqL1xuICAgIGRhdGVGaWx0ZXI6IChkYXRlOiBEKSA9PiBib29sZWFuO1xuICAgIC8qKiBFbWl0cyB3aGVuIGEgbmV3IGRhdGUgaXMgc2VsZWN0ZWQuICovXG4gICAgcmVhZG9ubHkgc2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEIHwgbnVsbD47XG4gICAgLyoqIEVtaXRzIHdoZW4gYW55IGRhdGUgaXMgc2VsZWN0ZWQuICovXG4gICAgcmVhZG9ubHkgX3VzZXJTZWxlY3Rpb246IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICAvKiogRW1pdHMgd2hlbiBhbnkgZGF0ZSBpcyBhY3RpdmF0ZWQuICovXG4gICAgcmVhZG9ubHkgYWN0aXZlRGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPEQ+O1xuICAgIC8qKiBUaGUgYm9keSBvZiBjYWxlbmRhciB0YWJsZSAqL1xuICAgIF9tYXRDYWxlbmRhckJvZHk6IGFueTtcbiAgICAvKiogVGhlIGxhYmVsIGZvciB0aGlzIG1vbnRoIChlLmcuIFwiSmFudWFyeSAyMDE3XCIpLiAqL1xuICAgIF9tb250aExhYmVsOiBzdHJpbmc7XG4gICAgLyoqIEdyaWQgb2YgY2FsZW5kYXIgY2VsbHMgcmVwcmVzZW50aW5nIHRoZSBkYXRlcyBvZiB0aGUgbW9udGguICovXG4gICAgX3dlZWtzOiBTYXRDYWxlbmRhckNlbGxbXVtdO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGJsYW5rIGNlbGxzIGluIHRoZSBmaXJzdCByb3cgYmVmb3JlIHRoZSAxc3Qgb2YgdGhlIG1vbnRoLiAqL1xuICAgIF9maXJzdFdlZWtPZmZzZXQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgZGF0ZSBvZiB0aGUgbW9udGggdGhhdCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIERhdGUgZmFsbHMgb24uXG4gICAgICogTnVsbCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIERhdGUgaXMgaW4gYW5vdGhlciBtb250aC5cbiAgICAgKi9cbiAgICBfc2VsZWN0ZWREYXRlOiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiBUaGUgZGF0ZSBvZiB0aGUgbW9udGggdGhhdCB0b2RheSBmYWxscyBvbi4gTnVsbCBpZiB0b2RheSBpcyBpbiBhbm90aGVyIG1vbnRoLiAqL1xuICAgIF90b2RheURhdGU6IG51bWJlciB8IG51bGw7XG4gICAgLyoqIFRoZSBuYW1lcyBvZiB0aGUgd2Vla2RheXMuICovXG4gICAgX3dlZWtkYXlzOiB7XG4gICAgICAgIGxvbmc6IHN0cmluZztcbiAgICAgICAgbmFycm93OiBzdHJpbmc7XG4gICAgfVtdO1xuICAgIGNvbnN0cnVjdG9yKF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIF9kYXRlRm9ybWF0czogTWF0RGF0ZUZvcm1hdHMsIF9kYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8RD4sIF9kaXI/OiBEaXJlY3Rpb25hbGl0eSk7XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgLyoqIEhhbmRsZXMgd2hlbiBhIG5ldyBkYXRlIGlzIHNlbGVjdGVkLiAqL1xuICAgIF9kYXRlU2VsZWN0ZWQoZGF0ZTogbnVtYmVyKTogdm9pZDtcbiAgICAvKiogSGFuZGxlcyBrZXlkb3duIGV2ZW50cyBvbiB0aGUgY2FsZW5kYXIgYm9keSB3aGVuIGNhbGVuZGFyIGlzIGluIG1vbnRoIHZpZXcuICovXG4gICAgX2hhbmRsZUNhbGVuZGFyQm9keUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xuICAgIC8qKiBJbml0aWFsaXplcyB0aGlzIG1vbnRoIHZpZXcuICovXG4gICAgX2luaXQoKTogdm9pZDtcbiAgICAvKiogRm9jdXNlcyB0aGUgYWN0aXZlIGNlbGwgYWZ0ZXIgdGhlIG1pY3JvdGFzayBxdWV1ZSBpcyBlbXB0eS4gKi9cbiAgICBfZm9jdXNBY3RpdmVDZWxsKCk6IHZvaWQ7XG4gICAgLyoqIENyZWF0ZXMgU2F0Q2FsZW5kYXJDZWxscyBmb3IgdGhlIGRhdGVzIGluIHRoaXMgbW9udGguICovXG4gICAgcHJpdmF0ZSBfY3JlYXRlV2Vla0NlbGxzKCk7XG4gICAgLyoqIERhdGUgZmlsdGVyIGZvciB0aGUgbW9udGggKi9cbiAgICBwcml2YXRlIF9zaG91bGRFbmFibGVEYXRlKGRhdGUpO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGUgaW4gdGhpcyBtb250aCB0aGF0IHRoZSBnaXZlbiBEYXRlIGZhbGxzIG9uLlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZ2l2ZW4gRGF0ZSBpcyBpbiBhbm90aGVyIG1vbnRoLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldERhdGVJbkN1cnJlbnRNb250aChkYXRlKTtcbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgdGhlIDIgZGF0ZXMgYXJlIG5vbi1udWxsIGFuZCBmYWxsIHdpdGhpbiB0aGUgc2FtZSBtb250aCBvZiB0aGUgc2FtZSB5ZWFyLiAqL1xuICAgIHByaXZhdGUgX2hhc1NhbWVNb250aEFuZFllYXIoZDEsIGQyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgVGhlIGdpdmVuIG9iamVjdCBpZiBpdCBpcyBib3RoIGEgZGF0ZSBpbnN0YW5jZSBhbmQgdmFsaWQsIG90aGVyd2lzZSBudWxsLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldFZhbGlkRGF0ZU9yTnVsbChvYmopO1xuICAgIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHRoZSBSVEwgbGF5b3V0IGRpcmVjdGlvbi4gKi9cbiAgICBwcml2YXRlIF9pc1J0bCgpO1xuICAgIC8qKiBVcGRhdGVzIHJhbmdlIGZ1bGwgcGFyYW1ldGVyIG9uIGVhY2ggYmVnaW4gb3IgZW5kIG9mIGludGVydmFsIHVwZGF0ZS5cbiAgICAgKiBOZWNlc3NhcnkgdG8gZGlzcGxheSBjYWxlbmRhci1ib2R5IGNvcnJlY3RseVxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlUmFuZ2VTcGVjaWZpY1ZhbHVlcygpO1xufVxuIl19